<html>
    <head>
        <title>Quiz Cards</title>
        <script src="https://cdn.tailwindcss.com"></script>
<script type="module">
    import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';
    window.pipeline = pipeline;
    env.allowLocalModels = false;
    // Dispatch a custom event so the rest of the app knows we are ready
    window.dispatchEvent(new Event('transformersReady'));
</script>
    </head>
    <body class="grid place-items-center grid-cols-3 grid-rows-3 bg-gray-900 text-white">
    <div id="study-option" class="w-[60vw] flex justify-center items-center gap-4 mb-10 col-start-2 col-end-2 row-start-1 row-end-1">
    
    <button id="blockBtn" class="bg-white/10 p-5 backdrop-blur-md rounded-md max-[1300px]:p-3" onclick="switchmode('block')">Block Mode</button>
    <button class="bg-white/10 p-5 backdrop-blur-md rounded-md max-[1300px]:text-sm max-[1300px]:p-3" onclick="switchmode('card')">Study Mode</button>
    <button class="bg-white/10 p-5 backdrop-blur-md rounded-md max-[1300px]:text-sm max-[1300px]:p-3" onclick="switchmode('test')">Test Mode</button>
    <button class="bg-white/10 p-5 backdrop-blur-md rounded-md max-[1300px]:text-sm max-[1300px]:p-3" onclick="shuffletest()">Shuffle Test</button>
    
    <div class="flex items-center bg-white/10 p-5 backdrop-blur-md rounded-md max-[1300px]:text-sm max-[1300px]:p-4">
        <input type="checkbox" id="shuffle-checkbox" class="m-0">
        <label for="shuffle-checkbox" class="ml-2 leading-none">Shuffle Cards</label>
    </div>

    </div>
            <button id="prev-button" class="col-start-1 row-start-2 row-end-2 bg-white/10 p-5 backdrop-blur-md rounded-md mr-[5%]" onclick="if (currentmode !== 'test') { currentIndex--; showingFront = true; showCard(currentIndex); } else { showtestquestion(--currentQuestion); }">Prev</button>
            <div id="test" class="relative bg-white/10 rounded-lg border border-white/30 m-10 h-[60vh] w-[60vw] col-start-2 col-end-2 row-start-2 row-end-2">
                <div id="timer" class="pointer-events-none absolute z-10 left-[0px] top-[0px] w-[0%] h-[100%] bg-green-500/10"></div>
                <div class="w-full top-[0px] left-[0px] max-h-[100%] p-6 overflow-y-scroll">
                <progress value="50" max="100" class="top-0px w-full mb-5" id="test-p"></progress>
                <h1 id="q" class="text-4xl">Question</h1>
                <div id="options" class="relative grid grid-cols-2 auto-rows-auto gap-4 mt-6 w-[100%] min-h-[30%] max-h-[70%]">
                    <!-- Options will be populated here -->
                    <div class="bg-white/20 rounded-lg border border-white/30 flex items-center justify-center hover:cursor-pointer">
                        <p>Question1</p>
                    </div>
                    <div class="bg-white/20 rounded-lg border border-white/30 flex items-center justify-center hover:cursor-pointer">
                        <p>Question2</p>
                    </div>
                    <div class="bg-white/20 rounded-lg border border-white/30 flex items-center justify-center hover:cursor-pointer">
                        <p>Question3</p>
                    </div>
                    <div class="bg-white/20 rounded-lg border border-white/30 flex items-center justify-center hover:cursor-pointer">
                        <p>Question4</p>
                    </div>
                </div>
                </div>
            </div>
            <div id="blockframe" style="display: none;" class="relative bg-white/10 rounded-lg border border-white/30 m-10 h-[60vh] w-[60vw] col-start-2 col-end-2 row-start-2 row-end-2">
                <iframe src="/blockblast" id="gameframe" class="w-full h-full">

                </iframe>
            </div>
            <div id="counter" class="absolute right-[2vw] top-1/2 -translate-y-1/2 flex flex-col justify-center gap-8 bg-white/10 backdrop-blur-md rounded-lg border border-white/30 p-8 h-[50vh] w-[12vw] z-20">
                <div class="text-center mt-[5%]">
                    <p class="text-sm uppercase tracking-widest opacity-60">Wrong</p>
                    <p id="wrong" class="text-5xl font-bold text-red-500">0</p>
                </div>

                <hr class="border borer-white w-[98%] mx-auto my-5">
            
                <div class="text-center mt-[5%]">
                    <p class="text-sm uppercase tracking-widest opacity-60">Right</p>
                    <p id="right" class="text-5xl font-bold text-green-500">0</p>
                </div>
            </div>
            <div class="bg-white/10 rounded-lg border border-white/30 m-10 p-6 hover:cursor-pointer h-[60vh] w-[60vw] col-start-2 col-end-2 row-start-2" id="card-container">
                <div id="front">
                <center class="w-[100%] h-[100%]">
                <p id="front-content" class="text-2xl"></p>
                <img id="img" src="" alt="" class="max-h-[70%] max-w-[70%] mt-4">
                </center>
            </div>
            <div id="back">
                <center>
                <p id="back-content" class="text-2xl"></p>
                </center>
            </div>
            <center>
            <p id="progress" class="absolute text-white text-2xl left-[45%] bottom-[25%]"></p>
            </center>
            </div>
            <button id="next-button" class="col-start-3 row-start-2 row-end-2 bg-white/10 p-5 backdrop-blur-md rounded-md ml-[5%]" onclick="if (currentmode !== 'test') { currentIndex++; showingFront = true; showCard(currentIndex); } else { showtestquestion(++currentQuestion); }">Next</button>
    </body> 
</html>
<script>
let block = false
let wrongq = 0;
let rightq = 0; 
let currentmode = '';
switchmode('card')
let currentIndex = 0;
let currentQuestion = 0;
let showingFront = true;
let cardSet = null;
let test = [];
let timerInterval = null;
const game = document.getElementById('gameframe').contentWindow
const par = new URLSearchParams(window.location.search);
const setname = decodeURIComponent(par.get("setname"));
const user = decodeURIComponent(par.get("user"));
const title = decodeURIComponent(par.get('title'));
const timerBar = document.getElementById('timer');

const frontDiv = document.getElementById('front');
const backDiv = document.getElementById('back');
const frontContent = document.getElementById('front-content');
const backContent = document.getElementById('back-content');
const cardContainer = document.getElementById('card-container');
const cardImage = document.getElementById('img');

backDiv.style.display = 'none';
let userStats = null;
function resetGame() {
    game.grid = Array(8).fill().map(() => Array(8).fill(null));
    game.score = 0;
    game.scoreDisplay.innerText = "0";
    game.generateNewSet();
}
game.addEventListener('needBlocks', (event) => {
    const scoreAtEmpty = event.detail.currentScore;
    setTimeout(function(){
    block = true
    document.getElementById('blockBtn').style.pointerEvents = 'none'
    switchmode('test')
    game.blockBlastGame.generateNewSet()
    }, 500)
    
});
game.addEventListener('gameOver', (event) =>{
    alert('game over')
    resetGame()
})
function moveItem(arr, fromIndex, toIndex) {
    const [item] = arr.splice(fromIndex, 1);
    

    arr.splice(toIndex, 0, item);
    
    return arr;
}
async function fetchAndBuildJSON() {
    const response = await fetch('/api/getstats');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    
    let result = ''; 
    
    while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        result += decoder.decode(value, { stream: true });
        
        console.log(`Downloaded ${result.length} characters...`);
    }

    const finalObject = JSON.parse(result);
    return finalObject;
}

function updatecount(){
    document.getElementById('wrong').textContent = wrongq
    document.getElementById('right').textContent = rightq
}
function showCard(index, event=false) {
    const shuffle = document.getElementById('shuffle-checkbox').checked;
    if (shuffle && !event) {
        index = Math.floor(Math.random() * cardSet.content.length);
        currentIndex = index;
    }
    if (!cardSet || !cardSet.content || index < 0 || index >= cardSet.content.length) return;
    frontContent.innerHTML = cardSet.content[index].question;
    backContent.innerHTML = cardSet.content[index].answer;
    cardImage.src = cardSet.content[index].image || '';
    frontDiv.style.display = showingFront ? '' : 'none';
    backDiv.style.display = showingFront ? 'none' : '';
    document.getElementById('progress').textContent = `Card ${index + 1} of ${cardSet.content.length}`;
}

cardContainer.addEventListener('click', () => {
    showingFront = !showingFront;
    showCard(currentIndex, event=true);
});

document.addEventListener('keydown', (e) => {
    if (!cardSet) return;
    if (e.key === 'ArrowRight') {
        if (currentIndex < cardSet.content.length - 1) {
            currentIndex++;
            showingFront = true;
            showCard(currentIndex);
        }
    } else if (e.key === 'ArrowLeft') {
        if (currentIndex > 0) {
            currentIndex--;
            showingFront = true;
            showCard(currentIndex);
        }
    }
});

async function getcards(name) {
    userStats = await fetchAndBuildJSON();
    
    if(!user || user === "null" || user === "undefined"){
            await fetch(`/api/cards`)
    .then(response => response.json())
    .then(async(data) => {
        cardSet = data.find(c => c.Title === name);
        if (cardSet && cardSet.content && cardSet.content.length > 0) {
            currentIndex = 0;
            showingFront = true;
            showCard(currentIndex);
            await generatetest();
        }
    });
    }
    else{
    await fetch(`/api/allcards?user=${user}&title=${title}`)
    .then(response => response.json())
    .then(async (data) => {
        cardSet = data[0]
        if (cardSet && cardSet.content && cardSet.content.length > 0) {
            currentIndex = 0;
            showingFront = true;
            showCard(currentIndex);
            await generatetest();
        }
    });
    }
}
function next(){
    if (currentmode !== 'test') { currentIndex++; showingFront = false; showCard(currentIndex); } else { showtestquestion(++currentQuestion); }
}
function switchmode(mode) {
    const testElements = ['test', 'counter'];
    const cardElements = ['card-container', 'prev-button', 'next-button'];
    const blockElements = ['blockframe'];
    if (mode === 'test') {
        currentmode = mode;
        // Show test
        testElements.forEach(id => document.getElementById(id).style.display = 'block');
        // Hide others
        cardElements.forEach(id => document.getElementById(id).style.display = 'none');
        blockElements.forEach(id => document.getElementById(id).style.display = 'none');
    }
    
    else if (mode === 'block') {
        currentmode = mode;
        // Show block
        blockElements.forEach(id => document.getElementById(id).style.display = 'block');
        // Hide others
        testElements.forEach(id => document.getElementById(id).style.display = 'none');
        cardElements.forEach(id => document.getElementById(id).style.display = 'none');
    }
    
    // 4. Logic for default/other mode
    else {
        currentmode = mode;
        // Show cards
        cardElements.forEach(id => document.getElementById(id).style.display = 'block');
        // Hide others
        testElements.forEach(id => document.getElementById(id).style.display = 'none');
        blockElements.forEach(id => document.getElementById(id).style.display = 'none');
    }
}
async function generatetest() {
    if (!cardSet || !cardSet.content) return;

    const qHeader = document.getElementById('q');
    const originalText = qHeader.innerText;
    qHeader.innerHTML = "<h1 class='test-4xl'>Loading Smart test</h1><br><p class='text-xl'>This can take a couple of minutes depending on the amount of cards</p>";
    document.getElementById('options').innerHTML = ''
    // 1. Define the worker code as a string
const workerCode = `
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';
        env.allowLocalModels = false;

        let extractor = null;

        function dotProduct(a, b) {
            return a.reduce((sum, val, i) => sum + val * b[i], 0);
        }

        self.onmessage = async (e) => {
            const { content } = e.data;
            if (!extractor) {
                extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
            }

            // Extract all unique potential text answers for distraction
            const textAnswers = content
                .map(c => c.answer)
                .filter(ans => ans && !ans.startsWith('data:image') && !ans.startsWith('http'));

            const embeddingsMap = new Map();
            for (const text of textAnswers) {
                if (!embeddingsMap.has(text)) {
                    const output = await extractor(text, { pooling: 'mean', normalize: true });
                    embeddingsMap.set(text, Array.from(output.data));
                }
            }

            const test = [];
            for (let i = 0; i < content.length; i++) {
                const currentData = content[i];
                const isImage = currentData.answer.startsWith('data:image') || currentData.answer.startsWith('http');
                
                let options = [];
                const currentVec = embeddingsMap.get(currentData.answer);

                if (isImage || !currentVec) {
                    // Filter out duplicates and the correct answer itself
                    const uniquePool = [...new Set(content.map(c => c.answer))]
                        .filter(ans => ans !== currentData.answer);

                    options = uniquePool
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 3);
                } else {
                    let scored = [];
                    // Using a Map for scored ensures we don't score the same text twice
                    embeddingsMap.forEach((vec, text) => {
                        if (text === currentData.answer) return;
                        
                        const score = dotProduct(currentVec, vec);
                        // 0.98 threshold helps avoid choosing synonyms/exact duplicates
                        if (score < 0.98) {
                            scored.push({ text, score });
                        }
                    });

                    // Sort by similarity (highest score first) and pick the top 3
                    options = scored
                        .sort((a, b) => b.score - a.score)
                        .map(d => d.text)
                        .slice(0, 3);
                }

                test.push({
                    question: currentData.question || currentData.image,
                    answer: currentData.answer || currentData.image,
                    options: options, // This will naturally be 0-3 items long
                    userans: '',
                    right: 0,
                    isHard: false
                });
            }
            self.postMessage(test);
        };
    `;

    // 2. Convert string to Blob and create a URL
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    const worker = new Worker(workerUrl, { type: 'module' });

    // 3. Send data to the worker
    worker.postMessage({ content: cardSet.content });

    worker.onmessage = (e) => {
        test = e.data;
        qHeader.innerText = originalText;
        if (typeof shuffletest === "function") shuffletest();
        console.log(cardSet)
        URL.revokeObjectURL(workerUrl);
        worker.terminate();
    };

    worker.onerror = (err) => {
        console.error("Worker error:", err);
        qHeader.innerText = "Error in AI processing.";
    };
}

function dotProduct(a, b) {
    return a.reduce((sum, val, i) => sum + val * b[i], 0);
}
function showtestquestion(index){
    if (!test || index < 0 || index >= test.length) return;
    
    currentQuestion = index;
    
    const progress = document.getElementById('test-p');
    progress.setAttribute('value', index);

    const q = test[index];
    const parent = document.getElementById('options');
    const question = document.getElementById('q');

    let alloptions = [...q.options, q.answer];
    alloptions.sort(() => Math.random() - 0.5);

    question.innerHTML = q.question.startsWith('data:image') 
        ? `<img src="${q.question}" class="max-h-[30%] max-w-[30%] mx-auto rounded-lg">` 
        : q.question;

    parent.innerHTML = '';

    // Generate Buttons
    alloptions.forEach(opt => {
        const safeValue = opt.replace(/"/g, '&quot;'); 

        parent.innerHTML += `
            <div 
                data-val="${safeValue}" 
                class="bg-white/20 rounded-lg border border-white/30 flex flex-col items-center justify-center hover:bg-white/30 hover:cursor-pointer p-4 transition-all" 
                onclick="check(this)"
            >
                <div class="pointer-events-none">
                    ${truncateToDetails(opt)}
                </div>
            </div>
        `;
    });
}
function check(ele){
    const allOptions = document.getElementById('options').children;
    for (let child of allOptions) {
        child.classList.remove('border-green-500', 'border-red-500', 'bg-green-500/20', 'bg-red-500/20');
        child.classList.add('border-white/30');
    }

    let selected = ele.getAttribute('data-val');
    let answerq = test[currentQuestion].answer;

    if (selected === answerq) {
        ele.classList.remove('border-white/30');
        ele.classList.add('border-green-500', 'bg-green-500/20');
        const ele2 = document.getElementById('test')
        ele2.classList.remove('bg-white/10')
        ele2.classList.add('bg-green-500/10')
        ele2.classList.remove('border-white/30')
        ele2.classList.add('border-green-500/20')
        const right = document.querySelector('div[data-val="'+ answerq +'"]')
        right.classList.remove('bg-white/10')
        right.classList.add('bg-green-500/30')
        right.classList.remove('border-white/30')
        right.classList.add('border-green-500/20')
        startTimer(2, 'green')
        test[currentQuestion].right++
        test[currentQuestion].userans = 'r'
        rightq++
        if (block){
            switchmode('block')
            document.getElementById('blockBtn').style.pointerEvents = 'auto'
        }
    } else {
        const ele2 = document.getElementById('test')
        ele2.classList.remove('border-white/30')
        ele2.classList.add('border-red-500/20')
        ele.classList.remove('border-white/30');
        ele.classList.add('border-red-500', 'bg-red-500/20');
        ele2.classList.remove('bg-white/10')
        ele2.classList.add('bg-red-500/10')
        const right = document.querySelector('div[data-val="'+ answerq +'"]')
        right.classList.remove('bg-white/10')
        right.classList.add('bg-green-500/30')
        right.classList.remove('border-white/30')
        right.classList.add('border-green-500/20')
        test[currentQuestion].right--
        test[currentQuestion].userans = 'w'
        shufflehardtoclose(currentQuestion);
        startTimer(2, 'red')
        wrongq++
    }
    updatecount()
}
function startTimer(seconds, color) {
    clearInterval(timerInterval);
    document.getElementById('test').classList.add('pointer-events-none')
    timerBar.style.width = '100%';
    
    timerBar.classList.remove('bg-red-500/10', 'bg-green-500/10'); 
    const colorName = color || 'green';
    timerBar.classList.add(`bg-${colorName}-500/10`);
    
    const totalTime = seconds * 1000; 
    let timeLeft = totalTime;
    const intervalRate = 10; 
    timerInterval = setInterval(() => {
        timeLeft -= intervalRate;
        const percentage = (timeLeft / totalTime) * 100;
        timerBar.style.width = `${percentage}%`;

        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            timerBar.style.width = '0%';
            
            showtestquestion(++currentQuestion);
            document.getElementById('test').classList.remove('pointer-events-none')
            const ele2 = document.getElementById('test');
            ele2.classList.remove('border-red-500/20', 'border-green-500/20', 'bg-green-500/10', 'bg-red-500/10');
            ele2.classList.add('border-white/30', 'bg-white/10');
        }
    }, intervalRate);
}

getcards(setname);
function truncateToDetails(text, lineLimit = 3) {
    if (text.startsWith('data:image') || text.startsWith('http')) return text;
    
    const lines = text.split(/<br\s*\/?>/i);
    if (lines.length <= lineLimit) return text;

    const visibleLines = lines.slice(0, lineLimit).join('<br>');
    const hiddenLines = lines.slice(lineLimit).join('<br>');

    return `
        <span>${visibleLines}</span>
        <details class="mt-2 cursor-pointer text-sm text-white/60" onclick="event.stopPropagation()">
            <summary class="hover:text-white text-white">Show More...</summary>
            <div class="mt-1 text-white border-t border-white/10 pt-1">${hiddenLines}</div>
        </details>
    `;
}
function shufflehardtoclose(currentIndex, gap = 2) {
    const recentMistakes = test.filter((q, index) => q.userans === 'w' && index <= currentIndex);

    recentMistakes.forEach(mistake => {
        const reQueue = { ...mistake, userans: '', right: 0 }; 
        
        const insertAt = Math.min(currentIndex + gap + Math.floor(Math.random() * 2), test.length);

        test.splice(insertAt, 0, reQueue);
        
        mistake.userans = 're-queued'; 
    });

    const progress = document.getElementById('test-p');
    progress.setAttribute('max', test.length);
}
function shuffletest() {
    test.sort(() => Math.random() - 0.5);
    test.sort((a, b) => {
        if (a.isHard && !b.isHard) return -1;
        if (!a.isHard && b.isHard) return 1; 
        return 0;
    });

    currentQuestion = 0;
    const progress = document.getElementById('test-p');
    progress.setAttribute('max', test.length);
    showtestquestion(0);
}
window.addEventListener('beforeunload', (event) => {
    let test2 = [];
    test.forEach(function(item) {
        if (item['userans'] !== '' && item['userans'] !== 're-queued') {
            let data = {
                setname: setname,
                question: item.question.startsWith('data:') ? 'image' : item.question,
                answer: item.answer.startsWith('data:') ? 'image' : item.answer, 
                options: item.options.map(opt => opt.startsWith('data:') ? 'image' : opt),
                userans: item.userans,
                right: item.right
            };
            test2.push(data);
        }
    });

    if (test2.length > 0 || rightq > 0 || wrongq > 0) {
        const payload = JSON.stringify({
            setname: setname,
            right: rightq, 
            wrong: wrongq,
            test: test2,
            ...(rightq > 1 && { percent: parseInt(((rightq / (rightq + wrongq)) * 100).toFixed(0))})
        });
        const success = navigator.sendBeacon('/api/savetest', new Blob([payload], { type: 'application/json' }));
        
        if (!success) {
            console.error("Beacon failed: Data too large or browser rejected.");
        }
    }
});
</script>